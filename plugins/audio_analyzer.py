"""Audio analysis plugin - extracts musical features."""

import logging
from typing import Any

import numpy as np
from PySide6.QtCore import QThread, Signal
from PySide6.QtWidgets import QHBoxLayout, QLabel, QWidget


def analyze_audio_file(filepath: str) -> dict[str, float]:
    """Analyze audio file and extract features.

    Args:
        filepath: Path to audio file

    Returns:
        Dict with tempo, spectral_centroid, zero_crossing_rate, rms_energy

    Raises:
        Exception: If analysis fails
    """
    import warnings

    import librosa

    # Suppress librosa/audioread warnings for corrupted files
    warnings.filterwarnings("ignore", category=UserWarning, module="librosa")

    # Load audio
    y, sr = librosa.load(filepath, sr=None, mono=True)

    if len(y) == 0:
        raise ValueError("Empty audio file")

    # Tempo detection
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    tempo = float(tempo) if tempo else 0.0

    # RMS energy
    rms = librosa.feature.rms(y=y)[0]
    rms_energy = float(np.mean(rms))

    # Spectral centroid (brightness)
    centroid = librosa.feature.spectral_centroid(y=y, sr=sr)[0]
    spectral_centroid = float(np.mean(centroid))

    # Zero crossing rate (percussiveness)
    zcr = librosa.feature.zero_crossing_rate(y)[0]
    zero_crossing_rate = float(np.mean(zcr))

    return {
        "tempo": tempo,
        "spectral_centroid": spectral_centroid,
        "zero_crossing_rate": zero_crossing_rate,
        "rms_energy": rms_energy,
    }


class AudioAnalyzerPlugin:
    """Analyze audio tracks and extract musical features."""

    name = "audio_analyzer"
    version = "1.0.0"
    description = "Audio feature extraction (tempo, energy, etc.)"
    modes = ["curating"]  # Only show stats in curating mode (batch always runs)

    # Class variable to keep batch processor alive (contains orphan workers)
    _batch_processor: Any = None

    def __init__(self) -> None:
        """Initialize plugin."""
        self.context: Any = None
        self.analysis_widget: AnalysisWidget | None = None
        self.current_track_id: int | None = None

    def initialize(self, context: Any) -> None:
        """Initialize plugin."""
        self.context = context

        # Subscribe to events
        from jukebox.core.event_bus import Events

        context.subscribe(Events.TRACK_LOADED, self._on_track_loaded)
        context.subscribe("audio_analysis_complete", self._on_analysis_complete)
        context.subscribe(Events.TRACKS_ADDED, self._on_tracks_added)

        # Auto-start batch analysis at startup (after waveforms)
        from PySide6.QtCore import QTimer

        QTimer.singleShot(2000, self._start_batch_analysis)  # 2s delay to let waveforms start first

    def _on_tracks_added(self) -> None:
        """Auto-analyze tracks when they are added."""
        # Use a delay to let waveforms generate first
        from PySide6.QtCore import QTimer

        QTimer.singleShot(1000, self._start_batch_analysis)

    def register_ui(self, ui_builder: Any) -> None:
        """Register analysis widget."""
        self.analysis_widget = AnalysisWidget()
        ui_builder.add_bottom_widget(self.analysis_widget)

        # Add menu for batch analysis
        menu = ui_builder.add_menu("&Analysis")
        ui_builder.add_menu_action(menu, "Analyze All Tracks (Batch)", self._start_batch_analysis)

    def _on_track_loaded(self, track_id: int) -> None:
        """Display track analysis when loaded, or add to priority queue if not cached."""
        if not self.analysis_widget:
            return

        # Store current track
        self.current_track_id = track_id

        # Check if analysis exists in cache (generated by waveform plugin)
        cached = self.context.database.conn.execute(
            "SELECT * FROM audio_analysis WHERE track_id = ?", (track_id,)
        ).fetchone()

        if cached:
            # Display cached analysis
            self.analysis_widget.display_analysis(
                {
                    "tempo": cached["tempo"],
                    "energy": cached["energy"],
                    "bass_energy": cached["bass_energy"],
                    "mid_energy": cached["mid_energy"],
                    "treble_energy": cached["treble_energy"],
                    "spectral_centroid": cached["spectral_centroid"],
                    "zero_crossing_rate": cached["zero_crossing_rate"],
                    "rms_energy": cached["rms_energy"],
                    "dynamic_range": cached["dynamic_range"],
                }
            )
        else:
            # Analysis not available yet - add to priority queue if batch is running
            self.analysis_widget.show_analyzing()

            if (
                AudioAnalyzerPlugin._batch_processor
                and AudioAnalyzerPlugin._batch_processor.is_running
            ):
                # Get filepath
                track = self.context.database.conn.execute(
                    "SELECT filepath FROM tracks WHERE id = ?", (track_id,)
                ).fetchone()

                if track:
                    item = (track_id, track["filepath"])
                    added = AudioAnalyzerPlugin._batch_processor.add_priority_item(item)
                    if added:
                        logging.info(f"[Audio Analysis] Track {track_id} added to priority queue")

    def _on_analysis_complete(self, track_id: int) -> None:
        """Handle audio analysis completion event."""
        if not self.analysis_widget:
            return

        # Only update if this is the currently displayed track
        if track_id != self.current_track_id:
            return

        # Reload analysis from database
        cached = self.context.database.conn.execute(
            "SELECT * FROM audio_analysis WHERE track_id = ?", (track_id,)
        ).fetchone()

        if cached:
            self.analysis_widget.display_analysis(
                {
                    "tempo": cached["tempo"],
                    "energy": cached["energy"],
                    "bass_energy": cached["bass_energy"],
                    "mid_energy": cached["mid_energy"],
                    "treble_energy": cached["treble_energy"],
                    "spectral_centroid": cached["spectral_centroid"],
                    "zero_crossing_rate": cached["zero_crossing_rate"],
                    "rms_energy": cached["rms_energy"],
                    "dynamic_range": cached["dynamic_range"],
                }
            )

    def _start_batch_analysis(self) -> None:
        """Start batch analysis of all tracks."""
        # Stop any running batch
        if AudioAnalyzerPlugin._batch_processor and AudioAnalyzerPlugin._batch_processor.is_running:
            logging.info("[Batch Analysis] Already running, stopping it first")
            AudioAnalyzerPlugin._batch_processor.stop()

        # Get all tracks from database
        tracks = self.context.database.conn.execute(
            "SELECT id, filepath FROM tracks ORDER BY id"
        ).fetchall()

        if not tracks:
            logging.info("[Batch Analysis] No tracks to analyze")
            return

        total_tracks = len(tracks)

        # Filter tracks that don't have complete analysis
        tracks_to_analyze = []
        already_analyzed = 0

        import os

        for track in tracks:
            analysis = self.context.database.conn.execute(
                "SELECT tempo, spectral_centroid, zero_crossing_rate, rms_energy FROM audio_analysis WHERE track_id = ?",
                (track["id"],),
            ).fetchone()

            filename = os.path.basename(track["filepath"])

            # Analyze if no analysis record OR if any advanced field is NULL
            needs_analysis = (
                not analysis
                or analysis["tempo"] is None
                or analysis["spectral_centroid"] is None
                or analysis["zero_crossing_rate"] is None
                or analysis["rms_energy"] is None
            )

            if needs_analysis:
                tracks_to_analyze.append((track["id"], track["filepath"]))
                if analysis:
                    logging.info(f"  Track {track['id']}: {filename} - NEEDS ANALYSIS (incomplete)")
                else:
                    logging.info(f"  Track {track['id']}: {filename} - NEEDS ANALYSIS (no record)")
            else:
                already_analyzed += 1
                logging.info(f"  Track {track['id']}: {filename} - already analyzed")

        logging.info(
            f"[Batch Analysis] Status: {already_analyzed} already done, {len(tracks_to_analyze)} to analyze (total: {total_tracks})"
        )

        if not tracks_to_analyze:
            logging.info("[Batch Analysis] All tracks already have complete analysis")
            self.context.emit("status_message", message="All tracks analyzed", color="#00FF00")
            return

        # Create batch processor
        from jukebox.core.batch_processor import BatchProcessor

        def worker_factory(item: tuple[int, str]) -> QThread:
            """Create analysis worker for a track."""
            track_id, filepath = item
            return AnalysisWorker(track_id=track_id, filepath=filepath)

        AudioAnalyzerPlugin._batch_processor = BatchProcessor(
            name="Audio Analysis",
            worker_factory=worker_factory,
            context=self.context,
        )

        # Connect signals
        AudioAnalyzerPlugin._batch_processor.item_complete.connect(self._on_batch_analysis_complete)
        AudioAnalyzerPlugin._batch_processor.item_error.connect(self._on_batch_analysis_error)

        # Start batch processing
        AudioAnalyzerPlugin._batch_processor.start(tracks_to_analyze)

    def _on_batch_analysis_complete(self, item: tuple[int, str], result: dict[str, float]) -> None:
        """Handle single analysis completion in batch."""
        track_id, filepath = item

        # Save to database (safe in main thread)
        try:
            import os

            # Check if row exists (created by waveform)
            existing = self.context.database.conn.execute(
                "SELECT track_id FROM audio_analysis WHERE track_id = ?", (track_id,)
            ).fetchone()

            if existing:
                # Update existing row
                self.context.database.conn.execute(
                    """
                    UPDATE audio_analysis
                    SET tempo = ?, spectral_centroid = ?, zero_crossing_rate = ?, rms_energy = ?
                    WHERE track_id = ?
                """,
                    (
                        result["tempo"],
                        result["spectral_centroid"],
                        result["zero_crossing_rate"],
                        result["rms_energy"],
                        track_id,
                    ),
                )
            else:
                # Create new row with only advanced analysis (no waveform data)
                self.context.database.conn.execute(
                    """
                    INSERT INTO audio_analysis (
                        track_id, tempo, spectral_centroid, zero_crossing_rate, rms_energy
                    )
                    VALUES (?, ?, ?, ?, ?)
                """,
                    (
                        track_id,
                        result["tempo"],
                        result["spectral_centroid"],
                        result["zero_crossing_rate"],
                        result["rms_energy"],
                    ),
                )

            self.context.database.conn.commit()

            # Emit event to update UI if this track is currently displayed
            self.context.emit("audio_analysis_complete", track_id=track_id)

            # DEBUG level: show filename
            filename = os.path.basename(filepath)
            logging.debug(f"[Batch Analysis] Saved: {filename}")

        except Exception as e:
            logging.error(f"[Batch Analysis] Failed to save results for track {track_id}: {e}", exc_info=True)

    def _on_batch_analysis_error(self, item: tuple[int, str], error: str) -> None:
        """Handle batch analysis error."""
        track_id, filepath = item
        import os

        filename = os.path.basename(filepath)
        # DEBUG level: show which file failed (BatchProcessor already logged the error)
        logging.debug(f"[Batch Analysis] Failed file: {filename}")

    def activate(self, mode: str) -> None:
        """Activate plugin for this mode."""
        # Show stats widget in curating mode
        if self.analysis_widget:
            self.analysis_widget.setVisible(True)
        logging.debug(f"[Audio Analysis] Activated for {mode} mode")

    def deactivate(self, mode: str) -> None:
        """Deactivate plugin for this mode."""
        # Hide stats widget in jukebox mode (batch continues)
        if self.analysis_widget:
            self.analysis_widget.setVisible(False)
        logging.debug(f"[Audio Analysis] Deactivated for {mode} mode")

    def shutdown(self) -> None:
        """Cleanup on application exit."""
        # Stop batch processor if running (but keep it alive in class variable)
        if AudioAnalyzerPlugin._batch_processor:
            logging.debug("[Audio Analysis] Stopping batch processor during shutdown")
            AudioAnalyzerPlugin._batch_processor.stop()
            # Disconnect all signals from batch processor
            try:
                AudioAnalyzerPlugin._batch_processor.item_complete.disconnect()
                AudioAnalyzerPlugin._batch_processor.item_error.disconnect()
            except (RuntimeError, TypeError):
                pass
        # Don't set to None - keep it alive so orphan workers can finish


class AnalysisWidget(QWidget):
    """Widget to display audio analysis results."""

    def __init__(self) -> None:
        """Initialize widget."""
        super().__init__()
        self._init_ui()

    def _init_ui(self) -> None:
        """Initialize UI."""
        from PySide6.QtWidgets import QVBoxLayout

        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(10, 5, 10, 5)
        main_layout.setSpacing(3)

        # Create labels with compact formatting
        self.energy_label = QLabel("Energy: --")
        self.bass_label = QLabel("Bass: --")
        self.mid_label = QLabel("Mid: --")
        self.treble_label = QLabel("Treble: --")
        self.dynamic_label = QLabel("Dynamic: --")
        self.tempo_label = QLabel("Tempo: --")
        self.centroid_label = QLabel("Brightness: --")
        self.zcr_label = QLabel("Percussive: --")
        self.rms_label = QLabel("RMS: --")

        # First row: waveform-based metrics
        row1 = QHBoxLayout()
        row1.setSpacing(15)
        row1.addWidget(QLabel("<b>Waveform:</b>"))
        row1.addWidget(self.energy_label)
        row1.addWidget(self.bass_label)
        row1.addWidget(self.mid_label)
        row1.addWidget(self.treble_label)
        row1.addWidget(self.dynamic_label)
        row1.addStretch()

        # Second row: advanced analysis metrics
        row2 = QHBoxLayout()
        row2.setSpacing(15)
        row2.addWidget(QLabel("<b>Analysis:</b>"))
        row2.addWidget(self.tempo_label)
        row2.addWidget(self.centroid_label)
        row2.addWidget(self.zcr_label)
        row2.addWidget(self.rms_label)
        row2.addStretch()

        main_layout.addLayout(row1)
        main_layout.addLayout(row2)

        self.setLayout(main_layout)
        self.setMaximumHeight(55)

    def show_analyzing(self) -> None:
        """Show analyzing state."""
        self.energy_label.setText("Energy: --")
        self.bass_label.setText("Bass: --")
        self.mid_label.setText("Mid: --")
        self.treble_label.setText("Treble: --")
        self.dynamic_label.setText("Dynamic: --")

    def display_analysis(self, analysis: dict[str, float | None]) -> None:
        """Display analysis results."""
        energy = analysis.get("energy")
        self.energy_label.setText(f"Energy: {energy:.3f}" if energy else "Energy: --")

        bass = analysis.get("bass_energy")
        self.bass_label.setText(f"Bass: {bass:.3f}" if bass else "Bass: --")

        mid = analysis.get("mid_energy")
        self.mid_label.setText(f"Mid: {mid:.3f}" if mid else "Mid: --")

        treble = analysis.get("treble_energy")
        self.treble_label.setText(f"Treble: {treble:.3f}" if treble else "Treble: --")

        dyn_range = analysis.get("dynamic_range")
        self.dynamic_label.setText(f"Dynamic: {dyn_range:.1f} dB" if dyn_range else "Dynamic: --")

        tempo = analysis.get("tempo")
        self.tempo_label.setText(f"Tempo: {tempo:.0f} BPM" if tempo else "Tempo: --")

        centroid = analysis.get("spectral_centroid")
        self.centroid_label.setText(
            f"Brightness: {centroid:.0f} Hz" if centroid else "Brightness: --"
        )

        zcr = analysis.get("zero_crossing_rate")
        self.zcr_label.setText(f"Percussive: {zcr:.3f}" if zcr else "Percussive: --")

        rms = analysis.get("rms_energy")
        self.rms_label.setText(f"RMS: {rms:.3f}" if rms else "RMS: --")


class AnalysisWorker(QThread):
    """Worker for batch audio analysis (for BatchProcessor)."""

    complete = Signal(dict)  # Result dict with analysis metrics
    error = Signal(str)  # Error message

    def __init__(self, track_id: int, filepath: str, parent: Any = None):
        """Initialize worker.

        Args:
            track_id: Track ID
            filepath: Path to audio file
            parent: Parent object
        """
        super().__init__(parent)
        self.track_id = track_id
        self.filepath = filepath
        # Set thread name for debugging
        import os

        self.setObjectName(f"AnalysisWorker-{track_id}-{os.path.basename(filepath)[:20]}")

    def run(self) -> None:
        """Perform analysis."""
        try:
            analysis = analyze_audio_file(self.filepath)
            self.complete.emit(analysis)
        except Exception as e:
            import os
            import traceback

            filename = os.path.basename(self.filepath)
            error_msg = f"Error analyzing {filename}: {e}"
            logging.error(f"[AudioAnalysisWorker] {error_msg}", exc_info=True)
            logging.error(f"[AudioAnalysisWorker] Full traceback:\n{traceback.format_exc()}")
            self.error.emit(error_msg)
