"""Audio analysis plugin - extracts musical features."""

import logging
from typing import Any

import numpy as np
from PySide6.QtCore import QThread, Qt, Signal
from PySide6.QtWidgets import QHBoxLayout, QLabel, QPushButton, QWidget


class AudioAnalyzerPlugin:
    """Analyze audio tracks and extract musical features."""

    name = "audio_analyzer"
    version = "1.0.0"
    description = "Audio feature extraction (tempo, energy, etc.)"

    # Class variable to keep orphan workers alive
    _orphan_workers: list[Any] = []

    def __init__(self) -> None:
        """Initialize plugin."""
        self.context: Any = None
        self.analysis_widget: AnalysisWidget | None = None
        self.current_worker: Any = None
        self.current_track_id: int | None = None

    def initialize(self, context: Any) -> None:
        """Initialize plugin."""
        self.context = context

        # Subscribe to track loaded event
        from jukebox.core.event_bus import Events

        context.subscribe(Events.TRACK_LOADED, self._on_track_loaded)
        context.subscribe("audio_analysis_complete", self._on_analysis_complete)

    def register_ui(self, ui_builder: Any) -> None:
        """Register analysis widget."""
        self.analysis_widget = AnalysisWidget()
        self.analysis_widget.analyze_more_clicked.connect(self._on_analyze_more_clicked)
        ui_builder.add_bottom_widget(self.analysis_widget)

    def _on_track_loaded(self, track_id: int) -> None:
        """Display track analysis when loaded."""
        if not self.analysis_widget:
            return

        # Store current track
        self.current_track_id = track_id

        # Check if analysis exists in cache (generated by waveform plugin)
        cached = self.context.database.conn.execute(
            "SELECT * FROM audio_analysis WHERE track_id = ?", (track_id,)
        ).fetchone()

        if cached:
            # Display cached analysis
            self.analysis_widget.display_analysis(
                {
                    "tempo": cached["tempo"],
                    "energy": cached["energy"],
                    "bass_energy": cached["bass_energy"],
                    "mid_energy": cached["mid_energy"],
                    "treble_energy": cached["treble_energy"],
                    "spectral_centroid": cached["spectral_centroid"],
                    "zero_crossing_rate": cached["zero_crossing_rate"],
                    "rms_energy": cached["rms_energy"],
                    "dynamic_range": cached["dynamic_range"],
                }
            )
        else:
            # Analysis not available yet (waveform not calculated)
            self.analysis_widget.show_analyzing()

    def _on_analysis_complete(self, track_id: int) -> None:
        """Handle audio analysis completion event."""
        if not self.analysis_widget:
            return

        # Reload analysis from database
        cached = self.context.database.conn.execute(
            "SELECT * FROM audio_analysis WHERE track_id = ?", (track_id,)
        ).fetchone()

        if cached:
            self.analysis_widget.display_analysis(
                {
                    "tempo": cached["tempo"],
                    "energy": cached["energy"],
                    "bass_energy": cached["bass_energy"],
                    "mid_energy": cached["mid_energy"],
                    "treble_energy": cached["treble_energy"],
                    "spectral_centroid": cached["spectral_centroid"],
                    "zero_crossing_rate": cached["zero_crossing_rate"],
                    "rms_energy": cached["rms_energy"],
                    "dynamic_range": cached["dynamic_range"],
                }
            )

    def _on_analyze_more_clicked(self) -> None:
        """Handle analyze more button click."""
        if self.current_track_id is None:
            return

        # Get filepath
        track = self.context.database.conn.execute(
            "SELECT filepath FROM tracks WHERE id = ?", (self.current_track_id,)
        ).fetchone()

        if not track:
            return

        # Cancel previous worker if running
        if self.current_worker:
            try:
                self.current_worker.analysis_complete.disconnect()
                self.current_worker.error.disconnect()
            except (RuntimeError, TypeError):
                pass
            self.current_worker.setParent(None)
            AudioAnalyzerPlugin._orphan_workers.append(self.current_worker)
            AudioAnalyzerPlugin._orphan_workers = [
                w for w in AudioAnalyzerPlugin._orphan_workers if w.isRunning()
            ]

        # Show analyzing state
        if self.analysis_widget:
            self.analysis_widget.set_button_state("analyzing")

        # Start advanced analysis
        self.current_worker = AdvancedAnalysisWorker(self.current_track_id, track["filepath"])
        self.current_worker.analysis_complete.connect(self._on_advanced_analysis_complete)
        self.current_worker.error.connect(self._on_advanced_analysis_error)
        self.current_worker.start()

    def _on_advanced_analysis_complete(self, track_id: int, analysis: dict[str, float]) -> None:
        """Handle advanced analysis completion."""
        if track_id != self.current_track_id:
            return

        # Update database with additional metrics
        try:
            self.context.database.conn.execute(
                """
                UPDATE audio_analysis
                SET tempo = ?, spectral_centroid = ?, zero_crossing_rate = ?, rms_energy = ?
                WHERE track_id = ?
            """,
                (
                    analysis["tempo"],
                    analysis["spectral_centroid"],
                    analysis["zero_crossing_rate"],
                    analysis["rms_energy"],
                    track_id,
                ),
            )
            self.context.database.conn.commit()

            # Emit event to refresh display
            self.context.emit("audio_analysis_complete", track_id=track_id)
        except Exception as e:
            logging.error(f"Failed to save advanced analysis: {e}")

        if self.analysis_widget:
            self.analysis_widget.set_button_state("idle")

    def _on_advanced_analysis_error(self, track_id: int, error_msg: str) -> None:
        """Handle advanced analysis error."""
        if track_id != self.current_track_id:
            return

        logging.error(f"Advanced analysis error for track {track_id}: {error_msg}")
        if self.analysis_widget:
            self.analysis_widget.set_button_state("error")
            self.analysis_widget.show_error(error_msg)

    def shutdown(self) -> None:
        """Cleanup."""
        if self.current_worker:
            try:
                self.current_worker.analysis_complete.disconnect()
                self.current_worker.error.disconnect()
            except (RuntimeError, TypeError):
                pass
            self.current_worker.setParent(None)
            AudioAnalyzerPlugin._orphan_workers.append(self.current_worker)
            AudioAnalyzerPlugin._orphan_workers = [
                w for w in AudioAnalyzerPlugin._orphan_workers if w.isRunning()
            ]
        self.current_worker = None


class AnalysisWidget(QWidget):
    """Widget to display audio analysis results."""

    analyze_more_clicked = Signal()

    def __init__(self) -> None:
        """Initialize widget."""
        super().__init__()
        self._init_ui()

    def _init_ui(self) -> None:
        """Initialize UI."""
        layout = QHBoxLayout()
        layout.setContentsMargins(10, 5, 10, 5)
        layout.setSpacing(15)

        # Create labels with compact formatting
        self.energy_label = QLabel("Energy: --")
        self.bass_label = QLabel("Bass: --")
        self.mid_label = QLabel("Mid: --")
        self.treble_label = QLabel("Treble: --")
        self.dynamic_label = QLabel("Dynamic: --")
        self.tempo_label = QLabel("Tempo: --")
        self.centroid_label = QLabel("Brightness: --")
        self.zcr_label = QLabel("Percussive: --")
        self.rms_label = QLabel("RMS: --")

        # Analyze more button
        self.analyze_button = QPushButton("Analyze More")
        self.analyze_button.setMaximumWidth(120)
        self.analyze_button.clicked.connect(self.analyze_more_clicked.emit)

        # Add to horizontal layout with stretch between groups
        layout.addWidget(QLabel("<b>Analysis:</b>"))
        layout.addWidget(self.energy_label)
        layout.addWidget(self.bass_label)
        layout.addWidget(self.mid_label)
        layout.addWidget(self.treble_label)
        layout.addWidget(self.dynamic_label)
        layout.addWidget(self.tempo_label)
        layout.addWidget(self.centroid_label)
        layout.addWidget(self.zcr_label)
        layout.addWidget(self.rms_label)
        layout.addStretch()
        layout.addWidget(self.analyze_button)

        self.setLayout(layout)
        self.setMaximumHeight(30)

    def show_analyzing(self) -> None:
        """Show analyzing state."""
        self.energy_label.setText("Energy: --")
        self.bass_label.setText("Bass: --")
        self.mid_label.setText("Mid: --")
        self.treble_label.setText("Treble: --")
        self.dynamic_label.setText("Dynamic: --")

    def show_error(self, error: str) -> None:
        """Show error state."""
        self.energy_label.setText(f"Error: {error}")

    def set_button_state(self, state: str) -> None:
        """Set button state (idle, analyzing, error)."""
        if state == "analyzing":
            self.analyze_button.setText("Analyzing...")
            self.analyze_button.setEnabled(False)
        elif state == "error":
            self.analyze_button.setText("Error")
            self.analyze_button.setEnabled(True)
        else:  # idle
            self.analyze_button.setText("Analyze More")
            self.analyze_button.setEnabled(True)

    def display_analysis(self, analysis: dict[str, float | None]) -> None:
        """Display analysis results."""
        energy = analysis.get("energy")
        self.energy_label.setText(f"Energy: {energy:.3f}" if energy else "Energy: --")

        bass = analysis.get("bass_energy")
        self.bass_label.setText(f"Bass: {bass:.3f}" if bass else "Bass: --")

        mid = analysis.get("mid_energy")
        self.mid_label.setText(f"Mid: {mid:.3f}" if mid else "Mid: --")

        treble = analysis.get("treble_energy")
        self.treble_label.setText(f"Treble: {treble:.3f}" if treble else "Treble: --")

        dyn_range = analysis.get("dynamic_range")
        self.dynamic_label.setText(f"Dynamic: {dyn_range:.1f} dB" if dyn_range else "Dynamic: --")

        tempo = analysis.get("tempo")
        self.tempo_label.setText(f"Tempo: {tempo:.0f} BPM" if tempo else "Tempo: --")

        centroid = analysis.get("spectral_centroid")
        self.centroid_label.setText(f"Brightness: {centroid:.0f} Hz" if centroid else "Brightness: --")

        zcr = analysis.get("zero_crossing_rate")
        self.zcr_label.setText(f"Percussive: {zcr:.3f}" if zcr else "Percussive: --")

        rms = analysis.get("rms_energy")
        self.rms_label.setText(f"RMS: {rms:.3f}" if rms else "RMS: --")


class AdvancedAnalysisWorker(QThread):
    """Background worker for advanced audio analysis (tempo, spectral features)."""

    analysis_complete = Signal(int, dict)  # track_id, analysis dict
    error = Signal(int, str)  # track_id, error message

    def __init__(self, track_id: int, filepath: str, parent: Any = None):
        """Initialize worker."""
        super().__init__(parent)
        self.track_id = track_id
        self.filepath = filepath

    def run(self) -> None:
        """Perform advanced analysis."""
        try:
            import librosa

            # Load audio
            y, sr = librosa.load(self.filepath, sr=None, mono=True)

            if len(y) == 0:
                self.error.emit(self.track_id, "Empty audio file")
                return

            # Tempo detection
            tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
            tempo = float(tempo) if tempo else 0.0

            # RMS energy
            rms = librosa.feature.rms(y=y)[0]
            rms_energy = float(np.mean(rms))

            # Spectral centroid (brightness)
            centroid = librosa.feature.spectral_centroid(y=y, sr=sr)[0]
            spectral_centroid = float(np.mean(centroid))

            # Zero crossing rate (percussiveness)
            zcr = librosa.feature.zero_crossing_rate(y)[0]
            zero_crossing_rate = float(np.mean(zcr))

            analysis = {
                "tempo": tempo,
                "spectral_centroid": spectral_centroid,
                "zero_crossing_rate": zero_crossing_rate,
                "rms_energy": rms_energy,
            }

            self.analysis_complete.emit(self.track_id, analysis)

        except Exception as e:
            self.error.emit(self.track_id, str(e))
